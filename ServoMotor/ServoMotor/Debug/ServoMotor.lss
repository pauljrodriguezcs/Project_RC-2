
ServoMotor.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00000ede  00000f72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ede  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000640  00800124  00800124  00000f96  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000f96  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000fc8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e8  00000000  00000000  00001008  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002407  00000000  00000000  000011f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f7e  00000000  00000000  000035f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001646  00000000  00000000  00004575  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004cc  00000000  00000000  00005bbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d76  00000000  00000000  00006088  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000012a5  00000000  00000000  00006dfe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001e0  00000000  00000000  000080a3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	e4 c3       	rjmp	.+1992   	; 0x7fe <__vector_13>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ee ed       	ldi	r30, 0xDE	; 222
  a0:	fe e0       	ldi	r31, 0x0E	; 14
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a4 32       	cpi	r26, 0x24	; 36
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	a4 e2       	ldi	r26, 0x24	; 36
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a4 36       	cpi	r26, 0x64	; 100
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	39 d2       	rcall	.+1138   	; 0x536 <main>
  c4:	0a c7       	rjmp	.+3604   	; 0xeda <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  cc:	ec 01       	movw	r28, r24
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  ce:	ea d4       	rcall	.+2516   	; 0xaa4 <vTaskSuspendAll>
  d0:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <__data_end>
  d4:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <__data_end+0x1>
  d8:	c9 01       	movw	r24, r18
  da:	8c 0f       	add	r24, r28
  dc:	9d 1f       	adc	r25, r29
  de:	8c 3d       	cpi	r24, 0xDC	; 220
  e0:	45 e0       	ldi	r20, 0x05	; 5
  e2:	94 07       	cpc	r25, r20
  e4:	58 f4       	brcc	.+22     	; 0xfc <pvPortMalloc+0x34>
  e6:	28 17       	cp	r18, r24
  e8:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
  ea:	58 f4       	brcc	.+22     	; 0x102 <pvPortMalloc+0x3a>
  ec:	e9 01       	movw	r28, r18
  ee:	ca 5d       	subi	r28, 0xDA	; 218
			xNextFreeByte += xWantedSize;			
  f0:	de 4f       	sbci	r29, 0xFE	; 254
  f2:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <__data_end+0x1>
  f6:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <__data_end>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
  fa:	05 c0       	rjmp	.+10     	; 0x106 <pvPortMalloc+0x3e>
  fc:	c0 e0       	ldi	r28, 0x00	; 0
  fe:	d0 e0       	ldi	r29, 0x00	; 0
 100:	02 c0       	rjmp	.+4      	; 0x106 <pvPortMalloc+0x3e>
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 102:	c0 e0       	ldi	r28, 0x00	; 0
 104:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif	

	return pvReturn;
}
 106:	95 d5       	rcall	.+2858   	; 0xc32 <xTaskResumeAll>
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 114:	03 96       	adiw	r24, 0x03	; 3
 116:	92 83       	std	Z+2, r25	; 0x02
 118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 11a:	2f ef       	ldi	r18, 0xFF	; 255
 11c:	3f ef       	ldi	r19, 0xFF	; 255
 11e:	34 83       	std	Z+4, r19	; 0x04
 120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 122:	96 83       	std	Z+6, r25	; 0x06
 124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 126:	90 87       	std	Z+8, r25	; 0x08
 128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 12a:	10 82       	st	Z, r1
 12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12e:	fc 01       	movw	r30, r24
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	10 86       	std	Z+8, r1	; 0x08
 134:	08 95       	ret

00000136 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	fc 01       	movw	r30, r24
 13c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 13e:	21 81       	ldd	r18, Z+1	; 0x01
 140:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 142:	e9 01       	movw	r28, r18
 144:	8a 81       	ldd	r24, Y+2	; 0x02
 146:	9b 81       	ldd	r25, Y+3	; 0x03
 148:	13 96       	adiw	r26, 0x03	; 3
 14a:	9c 93       	st	X, r25
 14c:	8e 93       	st	-X, r24
 14e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 150:	81 81       	ldd	r24, Z+1	; 0x01
 152:	92 81       	ldd	r25, Z+2	; 0x02
 154:	15 96       	adiw	r26, 0x05	; 5
 156:	9c 93       	st	X, r25
 158:	8e 93       	st	-X, r24
 15a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 15c:	8a 81       	ldd	r24, Y+2	; 0x02
 15e:	9b 81       	ldd	r25, Y+3	; 0x03
 160:	ec 01       	movw	r28, r24
 162:	7d 83       	std	Y+5, r23	; 0x05
 164:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 166:	e9 01       	movw	r28, r18
 168:	7b 83       	std	Y+3, r23	; 0x03
 16a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 16c:	72 83       	std	Z+2, r23	; 0x02
 16e:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 170:	19 96       	adiw	r26, 0x09	; 9
 172:	fc 93       	st	X, r31
 174:	ee 93       	st	-X, r30
 176:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 178:	80 81       	ld	r24, Z
 17a:	8f 5f       	subi	r24, 0xFF	; 255
 17c:	80 83       	st	Z, r24
}
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	08 95       	ret

00000184 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 184:	cf 93       	push	r28
 186:	df 93       	push	r29
 188:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 18a:	48 81       	ld	r20, Y
 18c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 18e:	4f 3f       	cpi	r20, 0xFF	; 255
 190:	2f ef       	ldi	r18, 0xFF	; 255
 192:	52 07       	cpc	r21, r18
 194:	31 f4       	brne	.+12     	; 0x1a2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 196:	dc 01       	movw	r26, r24
 198:	17 96       	adiw	r26, 0x07	; 7
 19a:	ed 91       	ld	r30, X+
 19c:	fc 91       	ld	r31, X
 19e:	18 97       	sbiw	r26, 0x08	; 8
 1a0:	17 c0       	rjmp	.+46     	; 0x1d0 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 1a2:	fc 01       	movw	r30, r24
 1a4:	33 96       	adiw	r30, 0x03	; 3
 1a6:	dc 01       	movw	r26, r24
 1a8:	15 96       	adiw	r26, 0x05	; 5
 1aa:	2d 91       	ld	r18, X+
 1ac:	3c 91       	ld	r19, X
 1ae:	16 97       	sbiw	r26, 0x06	; 6
 1b0:	d9 01       	movw	r26, r18
 1b2:	2d 91       	ld	r18, X+
 1b4:	3c 91       	ld	r19, X
 1b6:	42 17       	cp	r20, r18
 1b8:	53 07       	cpc	r21, r19
 1ba:	50 f0       	brcs	.+20     	; 0x1d0 <vListInsert+0x4c>
 1bc:	02 80       	ldd	r0, Z+2	; 0x02
 1be:	f3 81       	ldd	r31, Z+3	; 0x03
 1c0:	e0 2d       	mov	r30, r0
 1c2:	a2 81       	ldd	r26, Z+2	; 0x02
 1c4:	b3 81       	ldd	r27, Z+3	; 0x03
 1c6:	2d 91       	ld	r18, X+
 1c8:	3c 91       	ld	r19, X
 1ca:	42 17       	cp	r20, r18
 1cc:	53 07       	cpc	r21, r19
 1ce:	b0 f7       	brcc	.-20     	; 0x1bc <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d0:	a2 81       	ldd	r26, Z+2	; 0x02
 1d2:	b3 81       	ldd	r27, Z+3	; 0x03
 1d4:	bb 83       	std	Y+3, r27	; 0x03
 1d6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 1d8:	15 96       	adiw	r26, 0x05	; 5
 1da:	dc 93       	st	X, r29
 1dc:	ce 93       	st	-X, r28
 1de:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 1e0:	fd 83       	std	Y+5, r31	; 0x05
 1e2:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 1e4:	d3 83       	std	Z+3, r29	; 0x03
 1e6:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1e8:	99 87       	std	Y+9, r25	; 0x09
 1ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1ec:	fc 01       	movw	r30, r24
 1ee:	20 81       	ld	r18, Z
 1f0:	2f 5f       	subi	r18, 0xFF	; 255
 1f2:	20 83       	st	Z, r18
}
 1f4:	df 91       	pop	r29
 1f6:	cf 91       	pop	r28
 1f8:	08 95       	ret

000001fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 1fa:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1fc:	a2 81       	ldd	r26, Z+2	; 0x02
 1fe:	b3 81       	ldd	r27, Z+3	; 0x03
 200:	84 81       	ldd	r24, Z+4	; 0x04
 202:	95 81       	ldd	r25, Z+5	; 0x05
 204:	15 96       	adiw	r26, 0x05	; 5
 206:	9c 93       	st	X, r25
 208:	8e 93       	st	-X, r24
 20a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 20c:	a4 81       	ldd	r26, Z+4	; 0x04
 20e:	b5 81       	ldd	r27, Z+5	; 0x05
 210:	82 81       	ldd	r24, Z+2	; 0x02
 212:	93 81       	ldd	r25, Z+3	; 0x03
 214:	13 96       	adiw	r26, 0x03	; 3
 216:	9c 93       	st	X, r25
 218:	8e 93       	st	-X, r24
 21a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 21c:	a0 85       	ldd	r26, Z+8	; 0x08
 21e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 220:	11 96       	adiw	r26, 0x01	; 1
 222:	8d 91       	ld	r24, X+
 224:	9c 91       	ld	r25, X
 226:	12 97       	sbiw	r26, 0x02	; 2
 228:	e8 17       	cp	r30, r24
 22a:	f9 07       	cpc	r31, r25
 22c:	31 f4       	brne	.+12     	; 0x23a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 22e:	84 81       	ldd	r24, Z+4	; 0x04
 230:	95 81       	ldd	r25, Z+5	; 0x05
 232:	12 96       	adiw	r26, 0x02	; 2
 234:	9c 93       	st	X, r25
 236:	8e 93       	st	-X, r24
 238:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 23a:	11 86       	std	Z+9, r1	; 0x09
 23c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 23e:	8c 91       	ld	r24, X
 240:	81 50       	subi	r24, 0x01	; 1
 242:	8c 93       	st	X, r24
 244:	08 95       	ret

00000246 <BUTTON_Tick>:
}	
 
 enum SERVOState {servo_init,drive_low, drive_high} servo_state;

 void SERVO_Init(){
	 servo_state = servo_init;
 246:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <button_state>
 24a:	88 23       	and	r24, r24
 24c:	21 f0       	breq	.+8      	; 0x256 <BUTTON_Tick+0x10>
 24e:	81 30       	cpi	r24, 0x01	; 1
 250:	09 f4       	brne	.+2      	; 0x254 <BUTTON_Tick+0xe>
 252:	6f c0       	rjmp	.+222    	; 0x332 <BUTTON_Tick+0xec>
 254:	b2 c0       	rjmp	.+356    	; 0x3ba <BUTTON_Tick+0x174>
 256:	00 99       	sbic	0x00, 0	; 0
 258:	20 c0       	rjmp	.+64     	; 0x29a <BUTTON_Tick+0x54>
 25a:	80 b1       	in	r24, 0x00	; 0
 25c:	80 95       	com	r24
 25e:	82 fd       	sbrc	r24, 2
 260:	1c c0       	rjmp	.+56     	; 0x29a <BUTTON_Tick+0x54>
 262:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 266:	82 30       	cpi	r24, 0x02	; 2
 268:	08 f0       	brcs	.+2      	; 0x26c <BUTTON_Tick+0x26>
 26a:	a9 c0       	rjmp	.+338    	; 0x3be <BUTTON_Tick+0x178>
 26c:	91 e0       	ldi	r25, 0x01	; 1
 26e:	90 93 07 07 	sts	0x0707, r25	; 0x800707 <right>
 272:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <left>
 276:	92 e0       	ldi	r25, 0x02	; 2
 278:	90 93 05 07 	sts	0x0705, r25	; 0x800705 <max_servo>
 27c:	8f 5f       	subi	r24, 0xFF	; 255
 27e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 282:	81 30       	cpi	r24, 0x01	; 1
 284:	21 f0       	breq	.+8      	; 0x28e <BUTTON_Tick+0x48>
 286:	81 e0       	ldi	r24, 0x01	; 1
 288:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <needs_centering>
 28c:	02 c0       	rjmp	.+4      	; 0x292 <BUTTON_Tick+0x4c>
 28e:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <needs_centering>
 292:	81 e0       	ldi	r24, 0x01	; 1
 294:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <button_state>
 298:	08 95       	ret
 29a:	00 9b       	sbis	0x00, 0	; 0
 29c:	1f c0       	rjmp	.+62     	; 0x2dc <BUTTON_Tick+0x96>
 29e:	80 b1       	in	r24, 0x00	; 0
 2a0:	80 95       	com	r24
 2a2:	82 ff       	sbrs	r24, 2
 2a4:	1b c0       	rjmp	.+54     	; 0x2dc <BUTTON_Tick+0x96>
 2a6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 2aa:	88 23       	and	r24, r24
 2ac:	09 f4       	brne	.+2      	; 0x2b0 <BUTTON_Tick+0x6a>
 2ae:	87 c0       	rjmp	.+270    	; 0x3be <BUTTON_Tick+0x178>
 2b0:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <right>
 2b4:	91 e0       	ldi	r25, 0x01	; 1
 2b6:	90 93 06 07 	sts	0x0706, r25	; 0x800706 <left>
 2ba:	90 93 05 07 	sts	0x0705, r25	; 0x800705 <max_servo>
 2be:	81 50       	subi	r24, 0x01	; 1
 2c0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 2c4:	81 30       	cpi	r24, 0x01	; 1
 2c6:	21 f0       	breq	.+8      	; 0x2d0 <BUTTON_Tick+0x8a>
 2c8:	81 e0       	ldi	r24, 0x01	; 1
 2ca:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <needs_centering>
 2ce:	02 c0       	rjmp	.+4      	; 0x2d4 <BUTTON_Tick+0x8e>
 2d0:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <needs_centering>
 2d4:	81 e0       	ldi	r24, 0x01	; 1
 2d6:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <button_state>
 2da:	08 95       	ret
 2dc:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 2e0:	81 11       	cpse	r24, r1
 2e2:	0d c0       	rjmp	.+26     	; 0x2fe <BUTTON_Tick+0xb8>
 2e4:	81 e0       	ldi	r24, 0x01	; 1
 2e6:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <right>
 2ea:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <left>
 2ee:	92 e0       	ldi	r25, 0x02	; 2
 2f0:	90 93 05 07 	sts	0x0705, r25	; 0x800705 <max_servo>
 2f4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 2f8:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <needs_centering>
 2fc:	17 c0       	rjmp	.+46     	; 0x32c <BUTTON_Tick+0xe6>
 2fe:	82 30       	cpi	r24, 0x02	; 2
 300:	68 f0       	brcs	.+26     	; 0x31c <BUTTON_Tick+0xd6>
 302:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <right>
 306:	91 e0       	ldi	r25, 0x01	; 1
 308:	90 93 06 07 	sts	0x0706, r25	; 0x800706 <left>
 30c:	90 93 05 07 	sts	0x0705, r25	; 0x800705 <max_servo>
 310:	81 50       	subi	r24, 0x01	; 1
 312:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 316:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <needs_centering>
 31a:	08 c0       	rjmp	.+16     	; 0x32c <BUTTON_Tick+0xe6>
 31c:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <right>
 320:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <left>
 324:	10 92 05 07 	sts	0x0705, r1	; 0x800705 <max_servo>
 328:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <needs_centering>
 32c:	10 92 63 07 	sts	0x0763, r1	; 0x800763 <button_state>
 330:	08 95       	ret
 332:	00 99       	sbic	0x00, 0	; 0
 334:	1f c0       	rjmp	.+62     	; 0x374 <BUTTON_Tick+0x12e>
 336:	80 b1       	in	r24, 0x00	; 0
 338:	80 95       	com	r24
 33a:	82 fd       	sbrc	r24, 2
 33c:	1b c0       	rjmp	.+54     	; 0x374 <BUTTON_Tick+0x12e>
 33e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 342:	82 30       	cpi	r24, 0x02	; 2
 344:	98 f4       	brcc	.+38     	; 0x36c <BUTTON_Tick+0x126>
 346:	91 e0       	ldi	r25, 0x01	; 1
 348:	90 93 07 07 	sts	0x0707, r25	; 0x800707 <right>
 34c:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <left>
 350:	92 e0       	ldi	r25, 0x02	; 2
 352:	90 93 05 07 	sts	0x0705, r25	; 0x800705 <max_servo>
 356:	8f 5f       	subi	r24, 0xFF	; 255
 358:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 35c:	81 30       	cpi	r24, 0x01	; 1
 35e:	21 f0       	breq	.+8      	; 0x368 <BUTTON_Tick+0x122>
 360:	81 e0       	ldi	r24, 0x01	; 1
 362:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <needs_centering>
 366:	02 c0       	rjmp	.+4      	; 0x36c <BUTTON_Tick+0x126>
 368:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <needs_centering>
 36c:	81 e0       	ldi	r24, 0x01	; 1
 36e:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <button_state>
 372:	08 95       	ret
 374:	00 9b       	sbis	0x00, 0	; 0
 376:	1e c0       	rjmp	.+60     	; 0x3b4 <BUTTON_Tick+0x16e>
 378:	80 b1       	in	r24, 0x00	; 0
 37a:	80 95       	com	r24
 37c:	82 ff       	sbrs	r24, 2
 37e:	1a c0       	rjmp	.+52     	; 0x3b4 <BUTTON_Tick+0x16e>
 380:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 384:	88 23       	and	r24, r24
 386:	91 f0       	breq	.+36     	; 0x3ac <BUTTON_Tick+0x166>
 388:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <right>
 38c:	91 e0       	ldi	r25, 0x01	; 1
 38e:	90 93 06 07 	sts	0x0706, r25	; 0x800706 <left>
 392:	90 93 05 07 	sts	0x0705, r25	; 0x800705 <max_servo>
 396:	81 50       	subi	r24, 0x01	; 1
 398:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 39c:	81 30       	cpi	r24, 0x01	; 1
 39e:	21 f0       	breq	.+8      	; 0x3a8 <BUTTON_Tick+0x162>
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <needs_centering>
 3a6:	02 c0       	rjmp	.+4      	; 0x3ac <BUTTON_Tick+0x166>
 3a8:	10 92 02 07 	sts	0x0702, r1	; 0x800702 <needs_centering>
 3ac:	81 e0       	ldi	r24, 0x01	; 1
 3ae:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <button_state>
 3b2:	08 95       	ret
 3b4:	10 92 63 07 	sts	0x0763, r1	; 0x800763 <button_state>
 3b8:	08 95       	ret
 3ba:	10 92 63 07 	sts	0x0763, r1	; 0x800763 <button_state>
 3be:	08 95       	ret

000003c0 <BUTTONSecTask>:
 3c0:	10 92 63 07 	sts	0x0763, r1	; 0x800763 <button_state>
 3c4:	40 df       	rcall	.-384    	; 0x246 <BUTTON_Tick>
 3c6:	8c e2       	ldi	r24, 0x2C	; 44
 3c8:	91 e0       	ldi	r25, 0x01	; 1
 3ca:	b4 d4       	rcall	.+2408   	; 0xd34 <vTaskDelay>
 3cc:	fb cf       	rjmp	.-10     	; 0x3c4 <BUTTONSecTask+0x4>

000003ce <BUTTONSecPulse>:
 3ce:	af 92       	push	r10
 3d0:	bf 92       	push	r11
 3d2:	cf 92       	push	r12
 3d4:	df 92       	push	r13
 3d6:	ef 92       	push	r14
 3d8:	ff 92       	push	r15
 3da:	0f 93       	push	r16
 3dc:	a1 2c       	mov	r10, r1
 3de:	b1 2c       	mov	r11, r1
 3e0:	c1 2c       	mov	r12, r1
 3e2:	d1 2c       	mov	r13, r1
 3e4:	e1 2c       	mov	r14, r1
 3e6:	f1 2c       	mov	r15, r1
 3e8:	08 2f       	mov	r16, r24
 3ea:	20 e0       	ldi	r18, 0x00	; 0
 3ec:	30 e0       	ldi	r19, 0x00	; 0
 3ee:	45 e5       	ldi	r20, 0x55	; 85
 3f0:	50 e0       	ldi	r21, 0x00	; 0
 3f2:	63 e0       	ldi	r22, 0x03	; 3
 3f4:	71 e0       	ldi	r23, 0x01	; 1
 3f6:	80 ee       	ldi	r24, 0xE0	; 224
 3f8:	91 e0       	ldi	r25, 0x01	; 1
 3fa:	38 d2       	rcall	.+1136   	; 0x86c <xTaskGenericCreate>
 3fc:	0f 91       	pop	r16
 3fe:	ff 90       	pop	r15
 400:	ef 90       	pop	r14
 402:	df 90       	pop	r13
 404:	cf 90       	pop	r12
 406:	bf 90       	pop	r11
 408:	af 90       	pop	r10
 40a:	08 95       	ret

0000040c <SERVO_Tick>:
		default:
			break;
	}
	
	//Transitions
	switch(servo_state){
 40c:	80 91 62 07 	lds	r24, 0x0762	; 0x800762 <servo_state>
 410:	81 30       	cpi	r24, 0x01	; 1
 412:	09 f4       	brne	.+2      	; 0x416 <SERVO_Tick+0xa>
 414:	4a c0       	rjmp	.+148    	; 0x4aa <SERVO_Tick+0x9e>
 416:	18 f0       	brcs	.+6      	; 0x41e <SERVO_Tick+0x12>
 418:	82 30       	cpi	r24, 0x02	; 2
 41a:	d9 f0       	breq	.+54     	; 0x452 <SERVO_Tick+0x46>
 41c:	63 c0       	rjmp	.+198    	; 0x4e4 <SERVO_Tick+0xd8>
		case servo_init:
			if(left || right){
 41e:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <left>
 422:	81 11       	cpse	r24, r1
 424:	04 c0       	rjmp	.+8      	; 0x42e <SERVO_Tick+0x22>
 426:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <right>
 42a:	88 23       	and	r24, r24
 42c:	71 f0       	breq	.+28     	; 0x44a <SERVO_Tick+0x3e>
				servo_state = drive_high;
 42e:	82 e0       	ldi	r24, 0x02	; 2
 430:	80 93 62 07 	sts	0x0762, r24	; 0x800762 <servo_state>
				servo_counter = 0;
 434:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <servo_counter>
				min_servo = 20 - max_servo;
 438:	90 91 05 07 	lds	r25, 0x0705	; 0x800705 <max_servo>
 43c:	84 e1       	ldi	r24, 0x14	; 20
 43e:	89 1b       	sub	r24, r25
 440:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <min_servo>
				PORTD = 0x01;
 444:	81 e0       	ldi	r24, 0x01	; 1
 446:	8b b9       	out	0x0b, r24	; 11
 448:	08 95       	ret
			}
		  
			else{
				PORTD = 0x00;
 44a:	1b b8       	out	0x0b, r1	; 11
				servo_state = servo_init;
 44c:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <servo_state>
 450:	08 95       	ret
			}
			break;
		case drive_high:
			if((servo_counter < max_servo) && (left || right)){
 452:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <servo_counter>
 456:	90 91 05 07 	lds	r25, 0x0705	; 0x800705 <max_servo>
 45a:	89 17       	cp	r24, r25
 45c:	78 f4       	brcc	.+30     	; 0x47c <SERVO_Tick+0x70>
 45e:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <left>
 462:	91 11       	cpse	r25, r1
 464:	04 c0       	rjmp	.+8      	; 0x46e <SERVO_Tick+0x62>
 466:	90 91 07 07 	lds	r25, 0x0707	; 0x800707 <right>
 46a:	99 23       	and	r25, r25
 46c:	b1 f0       	breq	.+44     	; 0x49a <SERVO_Tick+0x8e>
				 ++servo_counter;
 46e:	8f 5f       	subi	r24, 0xFF	; 255
 470:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <servo_counter>
				servo_state = drive_high;
 474:	82 e0       	ldi	r24, 0x02	; 2
 476:	80 93 62 07 	sts	0x0762, r24	; 0x800762 <servo_state>
 47a:	08 95       	ret
			}
		  
			else if(!(servo_counter < max_servo) && (left || right)){
 47c:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <left>
 480:	81 11       	cpse	r24, r1
 482:	04 c0       	rjmp	.+8      	; 0x48c <SERVO_Tick+0x80>
 484:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <right>
 488:	88 23       	and	r24, r24
 48a:	39 f0       	breq	.+14     	; 0x49a <SERVO_Tick+0x8e>
				servo_counter = 0;
 48c:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <servo_counter>
				PORTD = 0x00;
 490:	1b b8       	out	0x0b, r1	; 11
				servo_state = drive_low;
 492:	81 e0       	ldi	r24, 0x01	; 1
 494:	80 93 62 07 	sts	0x0762, r24	; 0x800762 <servo_state>
 498:	08 95       	ret
			}
		  
			else{
				 left = 0;
 49a:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <left>
				right = 0;
 49e:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <right>
				PORTD = 0x00;
 4a2:	1b b8       	out	0x0b, r1	; 11
				servo_state = servo_init;
 4a4:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <servo_state>
 4a8:	08 95       	ret
			}
			break;
		  
		case drive_low:
			if((servo_counter < min_servo) && (left || right)){
 4aa:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <servo_counter>
 4ae:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <min_servo>
 4b2:	89 17       	cp	r24, r25
 4b4:	78 f4       	brcc	.+30     	; 0x4d4 <SERVO_Tick+0xc8>
 4b6:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <left>
 4ba:	91 11       	cpse	r25, r1
 4bc:	04 c0       	rjmp	.+8      	; 0x4c6 <SERVO_Tick+0xba>
 4be:	90 91 07 07 	lds	r25, 0x0707	; 0x800707 <right>
 4c2:	99 23       	and	r25, r25
 4c4:	39 f0       	breq	.+14     	; 0x4d4 <SERVO_Tick+0xc8>
				++servo_counter;
 4c6:	8f 5f       	subi	r24, 0xFF	; 255
 4c8:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <servo_counter>
				servo_state = drive_low;
 4cc:	81 e0       	ldi	r24, 0x01	; 1
 4ce:	80 93 62 07 	sts	0x0762, r24	; 0x800762 <servo_state>
 4d2:	08 95       	ret
			}
		  
			 else{
				left = 0;
 4d4:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <left>
				right = 0;
 4d8:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <right>
				PORTD = 0x00;
 4dc:	1b b8       	out	0x0b, r1	; 11
				servo_state = servo_init;
 4de:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <servo_state>
 4e2:	08 95       	ret
			}
		  
			break;
		  
		default:
			servo_state = servo_init;
 4e4:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <servo_state>
 4e8:	08 95       	ret

000004ea <SERVOSecTask>:
}	
 
 enum SERVOState {servo_init,drive_low, drive_high} servo_state;

 void SERVO_Init(){
	 servo_state = servo_init;
 4ea:	10 92 62 07 	sts	0x0762, r1	; 0x800762 <servo_state>
 {
	 SERVO_Init();
	 for(;;)
	 {
		 SERVO_Tick();
		 vTaskDelay(1);
 4ee:	8e df       	rcall	.-228    	; 0x40c <SERVO_Tick>
 4f0:	81 e0       	ldi	r24, 0x01	; 1
 4f2:	90 e0       	ldi	r25, 0x00	; 0
 4f4:	1f d4       	rcall	.+2110   	; 0xd34 <vTaskDelay>
 4f6:	fb cf       	rjmp	.-10     	; 0x4ee <SERVOSecTask+0x4>

000004f8 <SERVOSecPulse>:
	 }
 }

 void SERVOSecPulse(unsigned portBASE_TYPE Priority)
 {
 4f8:	af 92       	push	r10
 4fa:	bf 92       	push	r11
 4fc:	cf 92       	push	r12
 4fe:	df 92       	push	r13
 500:	ef 92       	push	r14
 502:	ff 92       	push	r15
 504:	0f 93       	push	r16
	 xTaskCreate(SERVOSecTask, (signed portCHAR *)"SERVOSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 506:	a1 2c       	mov	r10, r1
 508:	b1 2c       	mov	r11, r1
 50a:	c1 2c       	mov	r12, r1
 50c:	d1 2c       	mov	r13, r1
 50e:	e1 2c       	mov	r14, r1
 510:	f1 2c       	mov	r15, r1
 512:	08 2f       	mov	r16, r24
 514:	20 e0       	ldi	r18, 0x00	; 0
 516:	30 e0       	ldi	r19, 0x00	; 0
 518:	45 e5       	ldi	r20, 0x55	; 85
 51a:	50 e0       	ldi	r21, 0x00	; 0
 51c:	61 e1       	ldi	r22, 0x11	; 17
 51e:	71 e0       	ldi	r23, 0x01	; 1
 520:	85 e7       	ldi	r24, 0x75	; 117
 522:	92 e0       	ldi	r25, 0x02	; 2
 524:	a3 d1       	rcall	.+838    	; 0x86c <xTaskGenericCreate>
 }
 526:	0f 91       	pop	r16
 528:	ff 90       	pop	r15
 52a:	ef 90       	pop	r14
 52c:	df 90       	pop	r13
 52e:	cf 90       	pop	r12
 530:	bf 90       	pop	r11
 532:	af 90       	pop	r10
 534:	08 95       	ret

00000536 <main>:
 
int main(void) 
{ 
   DDRA = 0x00; PORTA = 0xFF;
 536:	11 b8       	out	0x01, r1	; 1
 538:	8f ef       	ldi	r24, 0xFF	; 255
 53a:	82 b9       	out	0x02, r24	; 2
   DDRD = 0xFF; PORTD = 0x00;
 53c:	8a b9       	out	0x0a, r24	; 10
 53e:	1b b8       	out	0x0b, r1	; 11
   
   //Start Tasks  
   BUTTONSecPulse(1);
 540:	81 e0       	ldi	r24, 0x01	; 1
   SERVOSecPulse(1);
 542:	45 df       	rcall	.-374    	; 0x3ce <BUTTONSecPulse>
    //RunSchedular 
   vTaskStartScheduler(); 
 544:	81 e0       	ldi	r24, 0x01	; 1
 546:	d8 df       	rcall	.-80     	; 0x4f8 <SERVOSecPulse>
 
   return 0; 
 548:	84 d2       	rcall	.+1288   	; 0xa52 <vTaskStartScheduler>
 54a:	80 e0       	ldi	r24, 0x00	; 0
 54c:	90 e0       	ldi	r25, 0x00	; 0
 54e:	08 95       	ret

00000550 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 550:	31 e1       	ldi	r19, 0x11	; 17
 552:	fc 01       	movw	r30, r24
 554:	30 83       	st	Z, r19
 556:	31 97       	sbiw	r30, 0x01	; 1
 558:	22 e2       	ldi	r18, 0x22	; 34
 55a:	20 83       	st	Z, r18
 55c:	31 97       	sbiw	r30, 0x01	; 1
 55e:	a3 e3       	ldi	r26, 0x33	; 51
 560:	a0 83       	st	Z, r26
 562:	31 97       	sbiw	r30, 0x01	; 1
 564:	60 83       	st	Z, r22
 566:	31 97       	sbiw	r30, 0x01	; 1
 568:	70 83       	st	Z, r23
 56a:	31 97       	sbiw	r30, 0x01	; 1
 56c:	10 82       	st	Z, r1
 56e:	31 97       	sbiw	r30, 0x01	; 1
 570:	60 e8       	ldi	r22, 0x80	; 128
 572:	60 83       	st	Z, r22
 574:	31 97       	sbiw	r30, 0x01	; 1
 576:	10 82       	st	Z, r1
 578:	31 97       	sbiw	r30, 0x01	; 1
 57a:	62 e0       	ldi	r22, 0x02	; 2
 57c:	60 83       	st	Z, r22
 57e:	31 97       	sbiw	r30, 0x01	; 1
 580:	63 e0       	ldi	r22, 0x03	; 3
 582:	60 83       	st	Z, r22
 584:	31 97       	sbiw	r30, 0x01	; 1
 586:	64 e0       	ldi	r22, 0x04	; 4
 588:	60 83       	st	Z, r22
 58a:	31 97       	sbiw	r30, 0x01	; 1
 58c:	65 e0       	ldi	r22, 0x05	; 5
 58e:	60 83       	st	Z, r22
 590:	31 97       	sbiw	r30, 0x01	; 1
 592:	66 e0       	ldi	r22, 0x06	; 6
 594:	60 83       	st	Z, r22
 596:	31 97       	sbiw	r30, 0x01	; 1
 598:	67 e0       	ldi	r22, 0x07	; 7
 59a:	60 83       	st	Z, r22
 59c:	31 97       	sbiw	r30, 0x01	; 1
 59e:	68 e0       	ldi	r22, 0x08	; 8
 5a0:	60 83       	st	Z, r22
 5a2:	31 97       	sbiw	r30, 0x01	; 1
 5a4:	69 e0       	ldi	r22, 0x09	; 9
 5a6:	60 83       	st	Z, r22
 5a8:	31 97       	sbiw	r30, 0x01	; 1
 5aa:	60 e1       	ldi	r22, 0x10	; 16
 5ac:	60 83       	st	Z, r22
 5ae:	31 97       	sbiw	r30, 0x01	; 1
 5b0:	30 83       	st	Z, r19
 5b2:	31 97       	sbiw	r30, 0x01	; 1
 5b4:	32 e1       	ldi	r19, 0x12	; 18
 5b6:	30 83       	st	Z, r19
 5b8:	31 97       	sbiw	r30, 0x01	; 1
 5ba:	33 e1       	ldi	r19, 0x13	; 19
 5bc:	30 83       	st	Z, r19
 5be:	31 97       	sbiw	r30, 0x01	; 1
 5c0:	34 e1       	ldi	r19, 0x14	; 20
 5c2:	30 83       	st	Z, r19
 5c4:	31 97       	sbiw	r30, 0x01	; 1
 5c6:	35 e1       	ldi	r19, 0x15	; 21
 5c8:	30 83       	st	Z, r19
 5ca:	31 97       	sbiw	r30, 0x01	; 1
 5cc:	36 e1       	ldi	r19, 0x16	; 22
 5ce:	30 83       	st	Z, r19
 5d0:	31 97       	sbiw	r30, 0x01	; 1
 5d2:	37 e1       	ldi	r19, 0x17	; 23
 5d4:	30 83       	st	Z, r19
 5d6:	31 97       	sbiw	r30, 0x01	; 1
 5d8:	38 e1       	ldi	r19, 0x18	; 24
 5da:	30 83       	st	Z, r19
 5dc:	31 97       	sbiw	r30, 0x01	; 1
 5de:	39 e1       	ldi	r19, 0x19	; 25
 5e0:	30 83       	st	Z, r19
 5e2:	31 97       	sbiw	r30, 0x01	; 1
 5e4:	30 e2       	ldi	r19, 0x20	; 32
 5e6:	30 83       	st	Z, r19
 5e8:	31 97       	sbiw	r30, 0x01	; 1
 5ea:	31 e2       	ldi	r19, 0x21	; 33
 5ec:	30 83       	st	Z, r19
 5ee:	31 97       	sbiw	r30, 0x01	; 1
 5f0:	20 83       	st	Z, r18
 5f2:	31 97       	sbiw	r30, 0x01	; 1
 5f4:	23 e2       	ldi	r18, 0x23	; 35
 5f6:	20 83       	st	Z, r18
 5f8:	31 97       	sbiw	r30, 0x01	; 1
 5fa:	40 83       	st	Z, r20
 5fc:	31 97       	sbiw	r30, 0x01	; 1
 5fe:	50 83       	st	Z, r21
 600:	31 97       	sbiw	r30, 0x01	; 1
 602:	26 e2       	ldi	r18, 0x26	; 38
 604:	20 83       	st	Z, r18
 606:	31 97       	sbiw	r30, 0x01	; 1
 608:	27 e2       	ldi	r18, 0x27	; 39
 60a:	20 83       	st	Z, r18
 60c:	31 97       	sbiw	r30, 0x01	; 1
 60e:	28 e2       	ldi	r18, 0x28	; 40
 610:	20 83       	st	Z, r18
 612:	31 97       	sbiw	r30, 0x01	; 1
 614:	29 e2       	ldi	r18, 0x29	; 41
 616:	20 83       	st	Z, r18
 618:	31 97       	sbiw	r30, 0x01	; 1
 61a:	20 e3       	ldi	r18, 0x30	; 48
 61c:	20 83       	st	Z, r18
 61e:	31 97       	sbiw	r30, 0x01	; 1
 620:	21 e3       	ldi	r18, 0x31	; 49
 622:	20 83       	st	Z, r18
 624:	86 97       	sbiw	r24, 0x26	; 38
 626:	08 95       	ret

00000628 <xPortStartScheduler>:
 628:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 62c:	8c e7       	ldi	r24, 0x7C	; 124
 62e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 632:	8b e0       	ldi	r24, 0x0B	; 11
 634:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 638:	ef e6       	ldi	r30, 0x6F	; 111
 63a:	f0 e0       	ldi	r31, 0x00	; 0
 63c:	80 81       	ld	r24, Z
 63e:	82 60       	ori	r24, 0x02	; 2
 640:	80 83       	st	Z, r24
 642:	a0 91 60 07 	lds	r26, 0x0760	; 0x800760 <pxCurrentTCB>
 646:	b0 91 61 07 	lds	r27, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 64a:	cd 91       	ld	r28, X+
 64c:	cd bf       	out	0x3d, r28	; 61
 64e:	dd 91       	ld	r29, X+
 650:	de bf       	out	0x3e, r29	; 62
 652:	ff 91       	pop	r31
 654:	ef 91       	pop	r30
 656:	df 91       	pop	r29
 658:	cf 91       	pop	r28
 65a:	bf 91       	pop	r27
 65c:	af 91       	pop	r26
 65e:	9f 91       	pop	r25
 660:	8f 91       	pop	r24
 662:	7f 91       	pop	r23
 664:	6f 91       	pop	r22
 666:	5f 91       	pop	r21
 668:	4f 91       	pop	r20
 66a:	3f 91       	pop	r19
 66c:	2f 91       	pop	r18
 66e:	1f 91       	pop	r17
 670:	0f 91       	pop	r16
 672:	ff 90       	pop	r15
 674:	ef 90       	pop	r14
 676:	df 90       	pop	r13
 678:	cf 90       	pop	r12
 67a:	bf 90       	pop	r11
 67c:	af 90       	pop	r10
 67e:	9f 90       	pop	r9
 680:	8f 90       	pop	r8
 682:	7f 90       	pop	r7
 684:	6f 90       	pop	r6
 686:	5f 90       	pop	r5
 688:	4f 90       	pop	r4
 68a:	3f 90       	pop	r3
 68c:	2f 90       	pop	r2
 68e:	1f 90       	pop	r1
 690:	0f 90       	pop	r0
 692:	0f be       	out	0x3f, r0	; 63
 694:	0f 90       	pop	r0
 696:	08 95       	ret
 698:	81 e0       	ldi	r24, 0x01	; 1
 69a:	08 95       	ret

0000069c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 69c:	0f 92       	push	r0
 69e:	0f b6       	in	r0, 0x3f	; 63
 6a0:	f8 94       	cli
 6a2:	0f 92       	push	r0
 6a4:	1f 92       	push	r1
 6a6:	11 24       	eor	r1, r1
 6a8:	2f 92       	push	r2
 6aa:	3f 92       	push	r3
 6ac:	4f 92       	push	r4
 6ae:	5f 92       	push	r5
 6b0:	6f 92       	push	r6
 6b2:	7f 92       	push	r7
 6b4:	8f 92       	push	r8
 6b6:	9f 92       	push	r9
 6b8:	af 92       	push	r10
 6ba:	bf 92       	push	r11
 6bc:	cf 92       	push	r12
 6be:	df 92       	push	r13
 6c0:	ef 92       	push	r14
 6c2:	ff 92       	push	r15
 6c4:	0f 93       	push	r16
 6c6:	1f 93       	push	r17
 6c8:	2f 93       	push	r18
 6ca:	3f 93       	push	r19
 6cc:	4f 93       	push	r20
 6ce:	5f 93       	push	r21
 6d0:	6f 93       	push	r22
 6d2:	7f 93       	push	r23
 6d4:	8f 93       	push	r24
 6d6:	9f 93       	push	r25
 6d8:	af 93       	push	r26
 6da:	bf 93       	push	r27
 6dc:	cf 93       	push	r28
 6de:	df 93       	push	r29
 6e0:	ef 93       	push	r30
 6e2:	ff 93       	push	r31
 6e4:	a0 91 60 07 	lds	r26, 0x0760	; 0x800760 <pxCurrentTCB>
 6e8:	b0 91 61 07 	lds	r27, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 6ec:	0d b6       	in	r0, 0x3d	; 61
 6ee:	0d 92       	st	X+, r0
 6f0:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
 6f2:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
 6f4:	70 d3       	rcall	.+1760   	; 0xdd6 <vTaskSwitchContext>
 6f6:	a0 91 60 07 	lds	r26, 0x0760	; 0x800760 <pxCurrentTCB>
 6fa:	b0 91 61 07 	lds	r27, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 6fe:	cd 91       	ld	r28, X+
 700:	cd bf       	out	0x3d, r28	; 61
 702:	dd 91       	ld	r29, X+
 704:	de bf       	out	0x3e, r29	; 62
 706:	ff 91       	pop	r31
 708:	ef 91       	pop	r30
 70a:	df 91       	pop	r29
 70c:	cf 91       	pop	r28
 70e:	bf 91       	pop	r27
 710:	af 91       	pop	r26
 712:	9f 91       	pop	r25
 714:	8f 91       	pop	r24
 716:	7f 91       	pop	r23
 718:	6f 91       	pop	r22
 71a:	5f 91       	pop	r21
 71c:	4f 91       	pop	r20
 71e:	3f 91       	pop	r19
 720:	2f 91       	pop	r18
 722:	1f 91       	pop	r17
 724:	0f 91       	pop	r16
 726:	ff 90       	pop	r15
 728:	ef 90       	pop	r14
 72a:	df 90       	pop	r13
 72c:	cf 90       	pop	r12
 72e:	bf 90       	pop	r11
 730:	af 90       	pop	r10
 732:	9f 90       	pop	r9
 734:	8f 90       	pop	r8
 736:	7f 90       	pop	r7
 738:	6f 90       	pop	r6
 73a:	5f 90       	pop	r5
 73c:	4f 90       	pop	r4
 73e:	3f 90       	pop	r3
 740:	2f 90       	pop	r2
 742:	1f 90       	pop	r1
 744:	0f 90       	pop	r0
 746:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
 748:	0f 90       	pop	r0
 74a:	08 95       	ret

0000074c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 74c:	0f 92       	push	r0
 74e:	0f b6       	in	r0, 0x3f	; 63
 750:	f8 94       	cli
 752:	0f 92       	push	r0
 754:	1f 92       	push	r1
 756:	11 24       	eor	r1, r1
 758:	2f 92       	push	r2
 75a:	3f 92       	push	r3
 75c:	4f 92       	push	r4
 75e:	5f 92       	push	r5
 760:	6f 92       	push	r6
 762:	7f 92       	push	r7
 764:	8f 92       	push	r8
 766:	9f 92       	push	r9
 768:	af 92       	push	r10
 76a:	bf 92       	push	r11
 76c:	cf 92       	push	r12
 76e:	df 92       	push	r13
 770:	ef 92       	push	r14
 772:	ff 92       	push	r15
 774:	0f 93       	push	r16
 776:	1f 93       	push	r17
 778:	2f 93       	push	r18
 77a:	3f 93       	push	r19
 77c:	4f 93       	push	r20
 77e:	5f 93       	push	r21
 780:	6f 93       	push	r22
 782:	7f 93       	push	r23
 784:	8f 93       	push	r24
 786:	9f 93       	push	r25
 788:	af 93       	push	r26
 78a:	bf 93       	push	r27
 78c:	cf 93       	push	r28
 78e:	df 93       	push	r29
 790:	ef 93       	push	r30
 792:	ff 93       	push	r31
 794:	a0 91 60 07 	lds	r26, 0x0760	; 0x800760 <pxCurrentTCB>
 798:	b0 91 61 07 	lds	r27, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 79c:	0d b6       	in	r0, 0x3d	; 61
 79e:	0d 92       	st	X+, r0
 7a0:	0e b6       	in	r0, 0x3e	; 62
	vTaskIncrementTick();
	vTaskSwitchContext();
 7a2:	0d 92       	st	X+, r0
 7a4:	85 d1       	rcall	.+778    	; 0xab0 <vTaskIncrementTick>
	portRESTORE_CONTEXT();
 7a6:	17 d3       	rcall	.+1582   	; 0xdd6 <vTaskSwitchContext>
 7a8:	a0 91 60 07 	lds	r26, 0x0760	; 0x800760 <pxCurrentTCB>
 7ac:	b0 91 61 07 	lds	r27, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 7b0:	cd 91       	ld	r28, X+
 7b2:	cd bf       	out	0x3d, r28	; 61
 7b4:	dd 91       	ld	r29, X+
 7b6:	de bf       	out	0x3e, r29	; 62
 7b8:	ff 91       	pop	r31
 7ba:	ef 91       	pop	r30
 7bc:	df 91       	pop	r29
 7be:	cf 91       	pop	r28
 7c0:	bf 91       	pop	r27
 7c2:	af 91       	pop	r26
 7c4:	9f 91       	pop	r25
 7c6:	8f 91       	pop	r24
 7c8:	7f 91       	pop	r23
 7ca:	6f 91       	pop	r22
 7cc:	5f 91       	pop	r21
 7ce:	4f 91       	pop	r20
 7d0:	3f 91       	pop	r19
 7d2:	2f 91       	pop	r18
 7d4:	1f 91       	pop	r17
 7d6:	0f 91       	pop	r16
 7d8:	ff 90       	pop	r15
 7da:	ef 90       	pop	r14
 7dc:	df 90       	pop	r13
 7de:	cf 90       	pop	r12
 7e0:	bf 90       	pop	r11
 7e2:	af 90       	pop	r10
 7e4:	9f 90       	pop	r9
 7e6:	8f 90       	pop	r8
 7e8:	7f 90       	pop	r7
 7ea:	6f 90       	pop	r6
 7ec:	5f 90       	pop	r5
 7ee:	4f 90       	pop	r4
 7f0:	3f 90       	pop	r3
 7f2:	2f 90       	pop	r2
 7f4:	1f 90       	pop	r1
 7f6:	0f 90       	pop	r0
 7f8:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
 7fa:	0f 90       	pop	r0
 7fc:	08 95       	ret

000007fe <__vector_13>:
}
 7fe:	a6 df       	rcall	.-180    	; 0x74c <vPortYieldFromTick>
 800:	18 95       	reti

00000802 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 802:	cf 93       	push	r28
 804:	df 93       	push	r29
 806:	ec 01       	movw	r28, r24
 808:	e0 91 60 07 	lds	r30, 0x0760	; 0x800760 <pxCurrentTCB>
 80c:	f0 91 61 07 	lds	r31, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 810:	93 83       	std	Z+3, r25	; 0x03
 812:	82 83       	std	Z+2, r24	; 0x02
 814:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <xTickCount>
 818:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <xTickCount+0x1>
 81c:	c8 17       	cp	r28, r24
 81e:	d9 07       	cpc	r29, r25
 820:	60 f4       	brcc	.+24     	; 0x83a <prvAddCurrentTaskToDelayedList+0x38>
 822:	60 91 60 07 	lds	r22, 0x0760	; 0x800760 <pxCurrentTCB>
 826:	70 91 61 07 	lds	r23, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 82a:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <pxOverflowDelayedTaskList>
 82e:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <pxOverflowDelayedTaskList+0x1>
 832:	6e 5f       	subi	r22, 0xFE	; 254
 834:	7f 4f       	sbci	r23, 0xFF	; 255
 836:	a6 dc       	rcall	.-1716   	; 0x184 <vListInsert>
 838:	16 c0       	rjmp	.+44     	; 0x866 <prvAddCurrentTaskToDelayedList+0x64>
 83a:	60 91 60 07 	lds	r22, 0x0760	; 0x800760 <pxCurrentTCB>
 83e:	70 91 61 07 	lds	r23, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 842:	80 91 28 07 	lds	r24, 0x0728	; 0x800728 <pxDelayedTaskList>
 846:	90 91 29 07 	lds	r25, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 84a:	6e 5f       	subi	r22, 0xFE	; 254
 84c:	7f 4f       	sbci	r23, 0xFF	; 255
 84e:	9a dc       	rcall	.-1740   	; 0x184 <vListInsert>
 850:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <xNextTaskUnblockTime>
 854:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <xNextTaskUnblockTime+0x1>
 858:	c8 17       	cp	r28, r24
 85a:	d9 07       	cpc	r29, r25
 85c:	20 f4       	brcc	.+8      	; 0x866 <prvAddCurrentTaskToDelayedList+0x64>
 85e:	d0 93 02 01 	sts	0x0102, r29	; 0x800102 <xNextTaskUnblockTime+0x1>
 862:	c0 93 01 01 	sts	0x0101, r28	; 0x800101 <xNextTaskUnblockTime>
 866:	df 91       	pop	r29
 868:	cf 91       	pop	r28
 86a:	08 95       	ret

0000086c <xTaskGenericCreate>:
 86c:	4f 92       	push	r4
 86e:	5f 92       	push	r5
 870:	6f 92       	push	r6
 872:	7f 92       	push	r7
 874:	8f 92       	push	r8
 876:	9f 92       	push	r9
 878:	af 92       	push	r10
 87a:	bf 92       	push	r11
 87c:	cf 92       	push	r12
 87e:	df 92       	push	r13
 880:	ef 92       	push	r14
 882:	ff 92       	push	r15
 884:	0f 93       	push	r16
 886:	1f 93       	push	r17
 888:	cf 93       	push	r28
 88a:	df 93       	push	r29
 88c:	5c 01       	movw	r10, r24
 88e:	4b 01       	movw	r8, r22
 890:	3a 01       	movw	r6, r20
 892:	29 01       	movw	r4, r18
 894:	81 e2       	ldi	r24, 0x21	; 33
 896:	90 e0       	ldi	r25, 0x00	; 0
 898:	17 dc       	rcall	.-2002   	; 0xc8 <pvPortMalloc>
 89a:	ec 01       	movw	r28, r24
 89c:	89 2b       	or	r24, r25
 89e:	09 f4       	brne	.+2      	; 0x8a2 <xTaskGenericCreate+0x36>
 8a0:	c6 c0       	rjmp	.+396    	; 0xa2e <xTaskGenericCreate+0x1c2>
 8a2:	c1 14       	cp	r12, r1
 8a4:	d1 04       	cpc	r13, r1
 8a6:	09 f0       	breq	.+2      	; 0x8aa <xTaskGenericCreate+0x3e>
 8a8:	be c0       	rjmp	.+380    	; 0xa26 <xTaskGenericCreate+0x1ba>
 8aa:	c3 01       	movw	r24, r6
 8ac:	0d dc       	rcall	.-2022   	; 0xc8 <pvPortMalloc>
 8ae:	98 8f       	std	Y+24, r25	; 0x18
 8b0:	8f 8b       	std	Y+23, r24	; 0x17
 8b2:	00 97       	sbiw	r24, 0x00	; 0
 8b4:	19 f4       	brne	.+6      	; 0x8bc <xTaskGenericCreate+0x50>
 8b6:	ce 01       	movw	r24, r28
 8b8:	2b dc       	rcall	.-1962   	; 0x110 <vPortFree>
 8ba:	b9 c0       	rjmp	.+370    	; 0xa2e <xTaskGenericCreate+0x1c2>
 8bc:	a3 01       	movw	r20, r6
 8be:	65 ea       	ldi	r22, 0xA5	; 165
 8c0:	70 e0       	ldi	r23, 0x00	; 0
 8c2:	f5 d2       	rcall	.+1514   	; 0xeae <memset>
 8c4:	93 01       	movw	r18, r6
 8c6:	21 50       	subi	r18, 0x01	; 1
 8c8:	31 09       	sbc	r19, r1
 8ca:	8f 89       	ldd	r24, Y+23	; 0x17
 8cc:	98 8d       	ldd	r25, Y+24	; 0x18
 8ce:	3c 01       	movw	r6, r24
 8d0:	62 0e       	add	r6, r18
 8d2:	73 1e       	adc	r7, r19
 8d4:	48 e0       	ldi	r20, 0x08	; 8
 8d6:	50 e0       	ldi	r21, 0x00	; 0
 8d8:	b4 01       	movw	r22, r8
 8da:	ce 01       	movw	r24, r28
 8dc:	49 96       	adiw	r24, 0x19	; 25
 8de:	ee d2       	rcall	.+1500   	; 0xebc <strncpy>
 8e0:	18 a2       	std	Y+32, r1	; 0x20
 8e2:	10 2f       	mov	r17, r16
 8e4:	04 30       	cpi	r16, 0x04	; 4
 8e6:	08 f0       	brcs	.+2      	; 0x8ea <xTaskGenericCreate+0x7e>
 8e8:	13 e0       	ldi	r17, 0x03	; 3
 8ea:	1e 8b       	std	Y+22, r17	; 0x16
 8ec:	6e 01       	movw	r12, r28
 8ee:	82 e0       	ldi	r24, 0x02	; 2
 8f0:	c8 0e       	add	r12, r24
 8f2:	d1 1c       	adc	r13, r1
 8f4:	c6 01       	movw	r24, r12
 8f6:	1b dc       	rcall	.-1994   	; 0x12e <vListInitialiseItem>
 8f8:	ce 01       	movw	r24, r28
 8fa:	0c 96       	adiw	r24, 0x0c	; 12
 8fc:	18 dc       	rcall	.-2000   	; 0x12e <vListInitialiseItem>
 8fe:	d9 87       	std	Y+9, r29	; 0x09
 900:	c8 87       	std	Y+8, r28	; 0x08
 902:	84 e0       	ldi	r24, 0x04	; 4
 904:	90 e0       	ldi	r25, 0x00	; 0
 906:	81 1b       	sub	r24, r17
 908:	91 09       	sbc	r25, r1
 90a:	9d 87       	std	Y+13, r25	; 0x0d
 90c:	8c 87       	std	Y+12, r24	; 0x0c
 90e:	db 8b       	std	Y+19, r29	; 0x13
 910:	ca 8b       	std	Y+18, r28	; 0x12
 912:	a2 01       	movw	r20, r4
 914:	b5 01       	movw	r22, r10
 916:	c3 01       	movw	r24, r6
 918:	1b de       	rcall	.-970    	; 0x550 <pxPortInitialiseStack>
 91a:	99 83       	std	Y+1, r25	; 0x01
 91c:	88 83       	st	Y, r24
 91e:	e1 14       	cp	r14, r1
 920:	f1 04       	cpc	r15, r1
 922:	19 f0       	breq	.+6      	; 0x92a <xTaskGenericCreate+0xbe>
 924:	f7 01       	movw	r30, r14
 926:	d1 83       	std	Z+1, r29	; 0x01
 928:	c0 83       	st	Z, r28
 92a:	0f b6       	in	r0, 0x3f	; 63
 92c:	f8 94       	cli
 92e:	0f 92       	push	r0
 930:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <uxCurrentNumberOfTasks>
 934:	8f 5f       	subi	r24, 0xFF	; 255
 936:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <uxCurrentNumberOfTasks>
 93a:	80 91 60 07 	lds	r24, 0x0760	; 0x800760 <pxCurrentTCB>
 93e:	90 91 61 07 	lds	r25, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 942:	89 2b       	or	r24, r25
 944:	69 f5       	brne	.+90     	; 0x9a0 <xTaskGenericCreate+0x134>
 946:	d0 93 61 07 	sts	0x0761, r29	; 0x800761 <pxCurrentTCB+0x1>
 94a:	c0 93 60 07 	sts	0x0760, r28	; 0x800760 <pxCurrentTCB>
 94e:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <uxCurrentNumberOfTasks>
 952:	81 30       	cpi	r24, 0x01	; 1
 954:	a1 f5       	brne	.+104    	; 0x9be <xTaskGenericCreate+0x152>
 956:	8c e3       	ldi	r24, 0x3C	; 60
 958:	97 e0       	ldi	r25, 0x07	; 7
 95a:	db db       	rcall	.-2122   	; 0x112 <vListInitialise>
 95c:	85 e4       	ldi	r24, 0x45	; 69
 95e:	97 e0       	ldi	r25, 0x07	; 7
 960:	d8 db       	rcall	.-2128   	; 0x112 <vListInitialise>
 962:	8e e4       	ldi	r24, 0x4E	; 78
 964:	97 e0       	ldi	r25, 0x07	; 7
 966:	d5 db       	rcall	.-2134   	; 0x112 <vListInitialise>
 968:	87 e5       	ldi	r24, 0x57	; 87
 96a:	97 e0       	ldi	r25, 0x07	; 7
 96c:	d2 db       	rcall	.-2140   	; 0x112 <vListInitialise>
 96e:	83 e3       	ldi	r24, 0x33	; 51
 970:	97 e0       	ldi	r25, 0x07	; 7
 972:	cf db       	rcall	.-2146   	; 0x112 <vListInitialise>
 974:	8a e2       	ldi	r24, 0x2A	; 42
 976:	97 e0       	ldi	r25, 0x07	; 7
 978:	cc db       	rcall	.-2152   	; 0x112 <vListInitialise>
 97a:	8d e1       	ldi	r24, 0x1D	; 29
 97c:	97 e0       	ldi	r25, 0x07	; 7
 97e:	c9 db       	rcall	.-2158   	; 0x112 <vListInitialise>
 980:	84 e1       	ldi	r24, 0x14	; 20
 982:	97 e0       	ldi	r25, 0x07	; 7
 984:	c6 db       	rcall	.-2164   	; 0x112 <vListInitialise>
 986:	83 e3       	ldi	r24, 0x33	; 51
 988:	97 e0       	ldi	r25, 0x07	; 7
 98a:	90 93 29 07 	sts	0x0729, r25	; 0x800729 <pxDelayedTaskList+0x1>
 98e:	80 93 28 07 	sts	0x0728, r24	; 0x800728 <pxDelayedTaskList>
 992:	8a e2       	ldi	r24, 0x2A	; 42
 994:	97 e0       	ldi	r25, 0x07	; 7
 996:	90 93 27 07 	sts	0x0727, r25	; 0x800727 <pxOverflowDelayedTaskList+0x1>
 99a:	80 93 26 07 	sts	0x0726, r24	; 0x800726 <pxOverflowDelayedTaskList>
 99e:	0f c0       	rjmp	.+30     	; 0x9be <xTaskGenericCreate+0x152>
 9a0:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <xSchedulerRunning>
 9a4:	81 11       	cpse	r24, r1
 9a6:	0b c0       	rjmp	.+22     	; 0x9be <xTaskGenericCreate+0x152>
 9a8:	e0 91 60 07 	lds	r30, 0x0760	; 0x800760 <pxCurrentTCB>
 9ac:	f0 91 61 07 	lds	r31, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 9b0:	86 89       	ldd	r24, Z+22	; 0x16
 9b2:	08 17       	cp	r16, r24
 9b4:	20 f0       	brcs	.+8      	; 0x9be <xTaskGenericCreate+0x152>
 9b6:	d0 93 61 07 	sts	0x0761, r29	; 0x800761 <pxCurrentTCB+0x1>
 9ba:	c0 93 60 07 	sts	0x0760, r28	; 0x800760 <pxCurrentTCB>
 9be:	8e 89       	ldd	r24, Y+22	; 0x16
 9c0:	90 91 0f 07 	lds	r25, 0x070F	; 0x80070f <uxTopUsedPriority>
 9c4:	98 17       	cp	r25, r24
 9c6:	10 f4       	brcc	.+4      	; 0x9cc <xTaskGenericCreate+0x160>
 9c8:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <uxTopUsedPriority>
 9cc:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTaskNumber>
 9d0:	9f 5f       	subi	r25, 0xFF	; 255
 9d2:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <uxTaskNumber>
 9d6:	90 91 0e 07 	lds	r25, 0x070E	; 0x80070e <uxTopReadyPriority>
 9da:	98 17       	cp	r25, r24
 9dc:	10 f4       	brcc	.+4      	; 0x9e2 <xTaskGenericCreate+0x176>
 9de:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxTopReadyPriority>
 9e2:	90 e0       	ldi	r25, 0x00	; 0
 9e4:	9c 01       	movw	r18, r24
 9e6:	22 0f       	add	r18, r18
 9e8:	33 1f       	adc	r19, r19
 9ea:	22 0f       	add	r18, r18
 9ec:	33 1f       	adc	r19, r19
 9ee:	22 0f       	add	r18, r18
 9f0:	33 1f       	adc	r19, r19
 9f2:	82 0f       	add	r24, r18
 9f4:	93 1f       	adc	r25, r19
 9f6:	b6 01       	movw	r22, r12
 9f8:	84 5c       	subi	r24, 0xC4	; 196
 9fa:	98 4f       	sbci	r25, 0xF8	; 248
 9fc:	9c db       	rcall	.-2248   	; 0x136 <vListInsertEnd>
 9fe:	0f 90       	pop	r0
 a00:	0f be       	out	0x3f, r0	; 63
 a02:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <xSchedulerRunning>
 a06:	88 23       	and	r24, r24
 a08:	51 f0       	breq	.+20     	; 0xa1e <xTaskGenericCreate+0x1b2>
 a0a:	e0 91 60 07 	lds	r30, 0x0760	; 0x800760 <pxCurrentTCB>
 a0e:	f0 91 61 07 	lds	r31, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 a12:	86 89       	ldd	r24, Z+22	; 0x16
 a14:	80 17       	cp	r24, r16
 a16:	28 f4       	brcc	.+10     	; 0xa22 <xTaskGenericCreate+0x1b6>
 a18:	41 de       	rcall	.-894    	; 0x69c <vPortYield>
 a1a:	81 e0       	ldi	r24, 0x01	; 1
 a1c:	09 c0       	rjmp	.+18     	; 0xa30 <xTaskGenericCreate+0x1c4>
 a1e:	81 e0       	ldi	r24, 0x01	; 1
 a20:	07 c0       	rjmp	.+14     	; 0xa30 <xTaskGenericCreate+0x1c4>
 a22:	81 e0       	ldi	r24, 0x01	; 1
 a24:	05 c0       	rjmp	.+10     	; 0xa30 <xTaskGenericCreate+0x1c4>
 a26:	d8 8e       	std	Y+24, r13	; 0x18
 a28:	cf 8a       	std	Y+23, r12	; 0x17
 a2a:	c6 01       	movw	r24, r12
 a2c:	47 cf       	rjmp	.-370    	; 0x8bc <xTaskGenericCreate+0x50>
 a2e:	8f ef       	ldi	r24, 0xFF	; 255
 a30:	df 91       	pop	r29
 a32:	cf 91       	pop	r28
 a34:	1f 91       	pop	r17
 a36:	0f 91       	pop	r16
 a38:	ff 90       	pop	r15
 a3a:	ef 90       	pop	r14
 a3c:	df 90       	pop	r13
 a3e:	cf 90       	pop	r12
 a40:	bf 90       	pop	r11
 a42:	af 90       	pop	r10
 a44:	9f 90       	pop	r9
 a46:	8f 90       	pop	r8
 a48:	7f 90       	pop	r7
 a4a:	6f 90       	pop	r6
 a4c:	5f 90       	pop	r5
 a4e:	4f 90       	pop	r4
 a50:	08 95       	ret

00000a52 <vTaskStartScheduler>:
 a52:	af 92       	push	r10
 a54:	bf 92       	push	r11
 a56:	cf 92       	push	r12
 a58:	df 92       	push	r13
 a5a:	ef 92       	push	r14
 a5c:	ff 92       	push	r15
 a5e:	0f 93       	push	r16
 a60:	a1 2c       	mov	r10, r1
 a62:	b1 2c       	mov	r11, r1
 a64:	c1 2c       	mov	r12, r1
 a66:	d1 2c       	mov	r13, r1
 a68:	e1 2c       	mov	r14, r1
 a6a:	f1 2c       	mov	r15, r1
 a6c:	00 e0       	ldi	r16, 0x00	; 0
 a6e:	20 e0       	ldi	r18, 0x00	; 0
 a70:	30 e0       	ldi	r19, 0x00	; 0
 a72:	45 e5       	ldi	r20, 0x55	; 85
 a74:	50 e0       	ldi	r21, 0x00	; 0
 a76:	6e e1       	ldi	r22, 0x1E	; 30
 a78:	71 e0       	ldi	r23, 0x01	; 1
 a7a:	85 eb       	ldi	r24, 0xB5	; 181
 a7c:	96 e0       	ldi	r25, 0x06	; 6
 a7e:	f6 de       	rcall	.-532    	; 0x86c <xTaskGenericCreate>
 a80:	81 30       	cpi	r24, 0x01	; 1
 a82:	41 f4       	brne	.+16     	; 0xa94 <vTaskStartScheduler+0x42>
 a84:	f8 94       	cli
 a86:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <xSchedulerRunning>
 a8a:	10 92 11 07 	sts	0x0711, r1	; 0x800711 <xTickCount+0x1>
 a8e:	10 92 10 07 	sts	0x0710, r1	; 0x800710 <xTickCount>
 a92:	ca dd       	rcall	.-1132   	; 0x628 <xPortStartScheduler>
 a94:	0f 91       	pop	r16
 a96:	ff 90       	pop	r15
 a98:	ef 90       	pop	r14
 a9a:	df 90       	pop	r13
 a9c:	cf 90       	pop	r12
 a9e:	bf 90       	pop	r11
 aa0:	af 90       	pop	r10
 aa2:	08 95       	ret

00000aa4 <vTaskSuspendAll>:
 aa4:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxSchedulerSuspended>
 aa8:	8f 5f       	subi	r24, 0xFF	; 255
 aaa:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxSchedulerSuspended>
 aae:	08 95       	ret

00000ab0 <vTaskIncrementTick>:
 ab0:	0f 93       	push	r16
 ab2:	1f 93       	push	r17
 ab4:	cf 93       	push	r28
 ab6:	df 93       	push	r29
 ab8:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxSchedulerSuspended>
 abc:	81 11       	cpse	r24, r1
 abe:	af c0       	rjmp	.+350    	; 0xc1e <vTaskIncrementTick+0x16e>
 ac0:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <xTickCount>
 ac4:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <xTickCount+0x1>
 ac8:	01 96       	adiw	r24, 0x01	; 1
 aca:	90 93 11 07 	sts	0x0711, r25	; 0x800711 <xTickCount+0x1>
 ace:	80 93 10 07 	sts	0x0710, r24	; 0x800710 <xTickCount>
 ad2:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <xTickCount>
 ad6:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <xTickCount+0x1>
 ada:	89 2b       	or	r24, r25
 adc:	99 f5       	brne	.+102    	; 0xb44 <vTaskIncrementTick+0x94>
 ade:	80 91 28 07 	lds	r24, 0x0728	; 0x800728 <pxDelayedTaskList>
 ae2:	90 91 29 07 	lds	r25, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 ae6:	20 91 26 07 	lds	r18, 0x0726	; 0x800726 <pxOverflowDelayedTaskList>
 aea:	30 91 27 07 	lds	r19, 0x0727	; 0x800727 <pxOverflowDelayedTaskList+0x1>
 aee:	30 93 29 07 	sts	0x0729, r19	; 0x800729 <pxDelayedTaskList+0x1>
 af2:	20 93 28 07 	sts	0x0728, r18	; 0x800728 <pxDelayedTaskList>
 af6:	90 93 27 07 	sts	0x0727, r25	; 0x800727 <pxOverflowDelayedTaskList+0x1>
 afa:	80 93 26 07 	sts	0x0726, r24	; 0x800726 <pxOverflowDelayedTaskList>
 afe:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xNumOfOverflows>
 b02:	8f 5f       	subi	r24, 0xFF	; 255
 b04:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xNumOfOverflows>
 b08:	e0 91 28 07 	lds	r30, 0x0728	; 0x800728 <pxDelayedTaskList>
 b0c:	f0 91 29 07 	lds	r31, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 b10:	80 81       	ld	r24, Z
 b12:	81 11       	cpse	r24, r1
 b14:	07 c0       	rjmp	.+14     	; 0xb24 <vTaskIncrementTick+0x74>
 b16:	8f ef       	ldi	r24, 0xFF	; 255
 b18:	9f ef       	ldi	r25, 0xFF	; 255
 b1a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 b1e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 b22:	10 c0       	rjmp	.+32     	; 0xb44 <vTaskIncrementTick+0x94>
 b24:	e0 91 28 07 	lds	r30, 0x0728	; 0x800728 <pxDelayedTaskList>
 b28:	f0 91 29 07 	lds	r31, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 b2c:	05 80       	ldd	r0, Z+5	; 0x05
 b2e:	f6 81       	ldd	r31, Z+6	; 0x06
 b30:	e0 2d       	mov	r30, r0
 b32:	06 80       	ldd	r0, Z+6	; 0x06
 b34:	f7 81       	ldd	r31, Z+7	; 0x07
 b36:	e0 2d       	mov	r30, r0
 b38:	82 81       	ldd	r24, Z+2	; 0x02
 b3a:	93 81       	ldd	r25, Z+3	; 0x03
 b3c:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 b40:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 b44:	20 91 10 07 	lds	r18, 0x0710	; 0x800710 <xTickCount>
 b48:	30 91 11 07 	lds	r19, 0x0711	; 0x800711 <xTickCount+0x1>
 b4c:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <xNextTaskUnblockTime>
 b50:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <xNextTaskUnblockTime+0x1>
 b54:	28 17       	cp	r18, r24
 b56:	39 07       	cpc	r19, r25
 b58:	08 f4       	brcc	.+2      	; 0xb5c <vTaskIncrementTick+0xac>
 b5a:	66 c0       	rjmp	.+204    	; 0xc28 <vTaskIncrementTick+0x178>
 b5c:	e0 91 28 07 	lds	r30, 0x0728	; 0x800728 <pxDelayedTaskList>
 b60:	f0 91 29 07 	lds	r31, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 b64:	80 81       	ld	r24, Z
 b66:	88 23       	and	r24, r24
 b68:	99 f0       	breq	.+38     	; 0xb90 <vTaskIncrementTick+0xe0>
 b6a:	e0 91 28 07 	lds	r30, 0x0728	; 0x800728 <pxDelayedTaskList>
 b6e:	f0 91 29 07 	lds	r31, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 b72:	05 80       	ldd	r0, Z+5	; 0x05
 b74:	f6 81       	ldd	r31, Z+6	; 0x06
 b76:	e0 2d       	mov	r30, r0
 b78:	c6 81       	ldd	r28, Z+6	; 0x06
 b7a:	d7 81       	ldd	r29, Z+7	; 0x07
 b7c:	8a 81       	ldd	r24, Y+2	; 0x02
 b7e:	9b 81       	ldd	r25, Y+3	; 0x03
 b80:	20 91 10 07 	lds	r18, 0x0710	; 0x800710 <xTickCount>
 b84:	30 91 11 07 	lds	r19, 0x0711	; 0x800711 <xTickCount+0x1>
 b88:	28 17       	cp	r18, r24
 b8a:	39 07       	cpc	r19, r25
 b8c:	f8 f4       	brcc	.+62     	; 0xbcc <vTaskIncrementTick+0x11c>
 b8e:	19 c0       	rjmp	.+50     	; 0xbc2 <vTaskIncrementTick+0x112>
 b90:	8f ef       	ldi	r24, 0xFF	; 255
 b92:	9f ef       	ldi	r25, 0xFF	; 255
 b94:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 b98:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 b9c:	45 c0       	rjmp	.+138    	; 0xc28 <vTaskIncrementTick+0x178>
 b9e:	e0 91 28 07 	lds	r30, 0x0728	; 0x800728 <pxDelayedTaskList>
 ba2:	f0 91 29 07 	lds	r31, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 ba6:	05 80       	ldd	r0, Z+5	; 0x05
 ba8:	f6 81       	ldd	r31, Z+6	; 0x06
 baa:	e0 2d       	mov	r30, r0
 bac:	c6 81       	ldd	r28, Z+6	; 0x06
 bae:	d7 81       	ldd	r29, Z+7	; 0x07
 bb0:	8a 81       	ldd	r24, Y+2	; 0x02
 bb2:	9b 81       	ldd	r25, Y+3	; 0x03
 bb4:	20 91 10 07 	lds	r18, 0x0710	; 0x800710 <xTickCount>
 bb8:	30 91 11 07 	lds	r19, 0x0711	; 0x800711 <xTickCount+0x1>
 bbc:	28 17       	cp	r18, r24
 bbe:	39 07       	cpc	r19, r25
 bc0:	28 f4       	brcc	.+10     	; 0xbcc <vTaskIncrementTick+0x11c>
 bc2:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 bc6:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 bca:	2e c0       	rjmp	.+92     	; 0xc28 <vTaskIncrementTick+0x178>
 bcc:	8e 01       	movw	r16, r28
 bce:	0e 5f       	subi	r16, 0xFE	; 254
 bd0:	1f 4f       	sbci	r17, 0xFF	; 255
 bd2:	c8 01       	movw	r24, r16
 bd4:	12 db       	rcall	.-2524   	; 0x1fa <vListRemove>
 bd6:	8c 89       	ldd	r24, Y+20	; 0x14
 bd8:	9d 89       	ldd	r25, Y+21	; 0x15
 bda:	89 2b       	or	r24, r25
 bdc:	19 f0       	breq	.+6      	; 0xbe4 <vTaskIncrementTick+0x134>
 bde:	ce 01       	movw	r24, r28
 be0:	0c 96       	adiw	r24, 0x0c	; 12
 be2:	0b db       	rcall	.-2538   	; 0x1fa <vListRemove>
 be4:	8e 89       	ldd	r24, Y+22	; 0x16
 be6:	90 91 0e 07 	lds	r25, 0x070E	; 0x80070e <uxTopReadyPriority>
 bea:	98 17       	cp	r25, r24
 bec:	10 f4       	brcc	.+4      	; 0xbf2 <vTaskIncrementTick+0x142>
 bee:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxTopReadyPriority>
 bf2:	90 e0       	ldi	r25, 0x00	; 0
 bf4:	9c 01       	movw	r18, r24
 bf6:	22 0f       	add	r18, r18
 bf8:	33 1f       	adc	r19, r19
 bfa:	22 0f       	add	r18, r18
 bfc:	33 1f       	adc	r19, r19
 bfe:	22 0f       	add	r18, r18
 c00:	33 1f       	adc	r19, r19
 c02:	82 0f       	add	r24, r18
 c04:	93 1f       	adc	r25, r19
 c06:	b8 01       	movw	r22, r16
 c08:	84 5c       	subi	r24, 0xC4	; 196
 c0a:	98 4f       	sbci	r25, 0xF8	; 248
 c0c:	94 da       	rcall	.-2776   	; 0x136 <vListInsertEnd>
 c0e:	e0 91 28 07 	lds	r30, 0x0728	; 0x800728 <pxDelayedTaskList>
 c12:	f0 91 29 07 	lds	r31, 0x0729	; 0x800729 <pxDelayedTaskList+0x1>
 c16:	80 81       	ld	r24, Z
 c18:	81 11       	cpse	r24, r1
 c1a:	c1 cf       	rjmp	.-126    	; 0xb9e <vTaskIncrementTick+0xee>
 c1c:	b9 cf       	rjmp	.-142    	; 0xb90 <vTaskIncrementTick+0xe0>
 c1e:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxMissedTicks>
 c22:	8f 5f       	subi	r24, 0xFF	; 255
 c24:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxMissedTicks>
 c28:	df 91       	pop	r29
 c2a:	cf 91       	pop	r28
 c2c:	1f 91       	pop	r17
 c2e:	0f 91       	pop	r16
 c30:	08 95       	ret

00000c32 <xTaskResumeAll>:
 c32:	cf 92       	push	r12
 c34:	df 92       	push	r13
 c36:	ef 92       	push	r14
 c38:	ff 92       	push	r15
 c3a:	0f 93       	push	r16
 c3c:	1f 93       	push	r17
 c3e:	cf 93       	push	r28
 c40:	df 93       	push	r29
 c42:	0f b6       	in	r0, 0x3f	; 63
 c44:	f8 94       	cli
 c46:	0f 92       	push	r0
 c48:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxSchedulerSuspended>
 c4c:	81 50       	subi	r24, 0x01	; 1
 c4e:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxSchedulerSuspended>
 c52:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxSchedulerSuspended>
 c56:	81 11       	cpse	r24, r1
 c58:	5f c0       	rjmp	.+190    	; 0xd18 <xTaskResumeAll+0xe6>
 c5a:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <uxCurrentNumberOfTasks>
 c5e:	81 11       	cpse	r24, r1
 c60:	2f c0       	rjmp	.+94     	; 0xcc0 <xTaskResumeAll+0x8e>
 c62:	5d c0       	rjmp	.+186    	; 0xd1e <xTaskResumeAll+0xec>
 c64:	d7 01       	movw	r26, r14
 c66:	15 96       	adiw	r26, 0x05	; 5
 c68:	ed 91       	ld	r30, X+
 c6a:	fc 91       	ld	r31, X
 c6c:	16 97       	sbiw	r26, 0x06	; 6
 c6e:	c6 81       	ldd	r28, Z+6	; 0x06
 c70:	d7 81       	ldd	r29, Z+7	; 0x07
 c72:	ce 01       	movw	r24, r28
 c74:	0c 96       	adiw	r24, 0x0c	; 12
 c76:	c1 da       	rcall	.-2686   	; 0x1fa <vListRemove>
 c78:	8e 01       	movw	r16, r28
 c7a:	0e 5f       	subi	r16, 0xFE	; 254
 c7c:	1f 4f       	sbci	r17, 0xFF	; 255
 c7e:	c8 01       	movw	r24, r16
 c80:	bc da       	rcall	.-2696   	; 0x1fa <vListRemove>
 c82:	8e 89       	ldd	r24, Y+22	; 0x16
 c84:	90 91 0e 07 	lds	r25, 0x070E	; 0x80070e <uxTopReadyPriority>
 c88:	98 17       	cp	r25, r24
 c8a:	10 f4       	brcc	.+4      	; 0xc90 <xTaskResumeAll+0x5e>
 c8c:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxTopReadyPriority>
 c90:	90 e0       	ldi	r25, 0x00	; 0
 c92:	9c 01       	movw	r18, r24
 c94:	22 0f       	add	r18, r18
 c96:	33 1f       	adc	r19, r19
 c98:	22 0f       	add	r18, r18
 c9a:	33 1f       	adc	r19, r19
 c9c:	22 0f       	add	r18, r18
 c9e:	33 1f       	adc	r19, r19
 ca0:	82 0f       	add	r24, r18
 ca2:	93 1f       	adc	r25, r19
 ca4:	b8 01       	movw	r22, r16
 ca6:	84 5c       	subi	r24, 0xC4	; 196
 ca8:	98 4f       	sbci	r25, 0xF8	; 248
 caa:	45 da       	rcall	.-2934   	; 0x136 <vListInsertEnd>
 cac:	e0 91 60 07 	lds	r30, 0x0760	; 0x800760 <pxCurrentTCB>
 cb0:	f0 91 61 07 	lds	r31, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
 cb4:	9e 89       	ldd	r25, Y+22	; 0x16
 cb6:	86 89       	ldd	r24, Z+22	; 0x16
 cb8:	98 17       	cp	r25, r24
 cba:	58 f0       	brcs	.+22     	; 0xcd2 <xTaskResumeAll+0xa0>
 cbc:	dc 2c       	mov	r13, r12
 cbe:	09 c0       	rjmp	.+18     	; 0xcd2 <xTaskResumeAll+0xa0>
 cc0:	d1 2c       	mov	r13, r1
 cc2:	0f 2e       	mov	r0, r31
 cc4:	fd e1       	ldi	r31, 0x1D	; 29
 cc6:	ef 2e       	mov	r14, r31
 cc8:	f7 e0       	ldi	r31, 0x07	; 7
 cca:	ff 2e       	mov	r15, r31
 ccc:	f0 2d       	mov	r31, r0
 cce:	cc 24       	eor	r12, r12
 cd0:	c3 94       	inc	r12
 cd2:	f7 01       	movw	r30, r14
 cd4:	80 81       	ld	r24, Z
 cd6:	81 11       	cpse	r24, r1
 cd8:	c5 cf       	rjmp	.-118    	; 0xc64 <xTaskResumeAll+0x32>
 cda:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxMissedTicks>
 cde:	88 23       	and	r24, r24
 ce0:	79 f0       	breq	.+30     	; 0xd00 <xTaskResumeAll+0xce>
 ce2:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxMissedTicks>
 ce6:	88 23       	and	r24, r24
 ce8:	91 f0       	breq	.+36     	; 0xd0e <xTaskResumeAll+0xdc>
 cea:	e2 de       	rcall	.-572    	; 0xab0 <vTaskIncrementTick>
 cec:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxMissedTicks>
 cf0:	81 50       	subi	r24, 0x01	; 1
 cf2:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxMissedTicks>
 cf6:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxMissedTicks>
 cfa:	81 11       	cpse	r24, r1
 cfc:	f6 cf       	rjmp	.-20     	; 0xcea <xTaskResumeAll+0xb8>
 cfe:	07 c0       	rjmp	.+14     	; 0xd0e <xTaskResumeAll+0xdc>
 d00:	f1 e0       	ldi	r31, 0x01	; 1
 d02:	df 16       	cp	r13, r31
 d04:	21 f0       	breq	.+8      	; 0xd0e <xTaskResumeAll+0xdc>
 d06:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xMissedYield>
 d0a:	81 30       	cpi	r24, 0x01	; 1
 d0c:	39 f4       	brne	.+14     	; 0xd1c <xTaskResumeAll+0xea>
 d0e:	10 92 0a 07 	sts	0x070A, r1	; 0x80070a <xMissedYield>
 d12:	c4 dc       	rcall	.-1656   	; 0x69c <vPortYield>
 d14:	81 e0       	ldi	r24, 0x01	; 1
 d16:	03 c0       	rjmp	.+6      	; 0xd1e <xTaskResumeAll+0xec>
 d18:	80 e0       	ldi	r24, 0x00	; 0
 d1a:	01 c0       	rjmp	.+2      	; 0xd1e <xTaskResumeAll+0xec>
 d1c:	80 e0       	ldi	r24, 0x00	; 0
 d1e:	0f 90       	pop	r0
 d20:	0f be       	out	0x3f, r0	; 63
 d22:	df 91       	pop	r29
 d24:	cf 91       	pop	r28
 d26:	1f 91       	pop	r17
 d28:	0f 91       	pop	r16
 d2a:	ff 90       	pop	r15
 d2c:	ef 90       	pop	r14
 d2e:	df 90       	pop	r13
 d30:	cf 90       	pop	r12
 d32:	08 95       	ret

00000d34 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 d34:	cf 93       	push	r28
 d36:	df 93       	push	r29
 d38:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 d3a:	89 2b       	or	r24, r25
		{
			vTaskSuspendAll();
 d3c:	91 f0       	breq	.+36     	; 0xd62 <vTaskDelay+0x2e>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 d3e:	b2 de       	rcall	.-668    	; 0xaa4 <vTaskSuspendAll>
 d40:	80 91 10 07 	lds	r24, 0x0710	; 0x800710 <xTickCount>
 d44:	90 91 11 07 	lds	r25, 0x0711	; 0x800711 <xTickCount+0x1>
 d48:	c8 0f       	add	r28, r24

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 d4a:	d9 1f       	adc	r29, r25
 d4c:	80 91 60 07 	lds	r24, 0x0760	; 0x800760 <pxCurrentTCB>
 d50:	90 91 61 07 	lds	r25, 0x0761	; 0x800761 <pxCurrentTCB+0x1>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
			}
			xAlreadyYielded = xTaskResumeAll();
 d54:	02 96       	adiw	r24, 0x02	; 2
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 d56:	51 da       	rcall	.-2910   	; 0x1fa <vListRemove>
 d58:	ce 01       	movw	r24, r28
		{
			portYIELD_WITHIN_API();
 d5a:	53 dd       	rcall	.-1370   	; 0x802 <prvAddCurrentTaskToDelayedList>
 d5c:	6a df       	rcall	.-300    	; 0xc32 <xTaskResumeAll>
		}
	}
 d5e:	81 11       	cpse	r24, r1
 d60:	01 c0       	rjmp	.+2      	; 0xd64 <vTaskDelay+0x30>
 d62:	9c dc       	rcall	.-1736   	; 0x69c <vPortYield>
 d64:	df 91       	pop	r29
 d66:	cf 91       	pop	r28
 d68:	08 95       	ret

00000d6a <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d6a:	0f 2e       	mov	r0, r31
 d6c:	f4 e1       	ldi	r31, 0x14	; 20
 d6e:	ef 2e       	mov	r14, r31
 d70:	f7 e0       	ldi	r31, 0x07	; 7
 d72:	ff 2e       	mov	r15, r31
 d74:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 d76:	cc e3       	ldi	r28, 0x3C	; 60
 d78:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 d7a:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <uxTasksDeleted>
 d7e:	88 23       	and	r24, r24
		{
			vTaskSuspendAll();
 d80:	29 f1       	breq	.+74     	; 0xdcc <prvIdleTask+0x62>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d82:	90 de       	rcall	.-736    	; 0xaa4 <vTaskSuspendAll>
			xTaskResumeAll();
 d84:	d7 01       	movw	r26, r14
 d86:	1c 91       	ld	r17, X

			if( xListIsEmpty == pdFALSE )
 d88:	54 df       	rcall	.-344    	; 0xc32 <xTaskResumeAll>
 d8a:	11 23       	and	r17, r17
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 d8c:	f9 f0       	breq	.+62     	; 0xdcc <prvIdleTask+0x62>
 d8e:	0f b6       	in	r0, 0x3f	; 63
 d90:	f8 94       	cli
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 d92:	0f 92       	push	r0
 d94:	d7 01       	movw	r26, r14
 d96:	15 96       	adiw	r26, 0x05	; 5
 d98:	ed 91       	ld	r30, X+
 d9a:	fc 91       	ld	r31, X
 d9c:	16 97       	sbiw	r26, 0x06	; 6
					vListRemove( &( pxTCB->xGenericListItem ) );
 d9e:	06 81       	ldd	r16, Z+6	; 0x06
 da0:	17 81       	ldd	r17, Z+7	; 0x07
 da2:	c8 01       	movw	r24, r16
					--uxCurrentNumberOfTasks;
 da4:	02 96       	adiw	r24, 0x02	; 2
 da6:	29 da       	rcall	.-2990   	; 0x1fa <vListRemove>
 da8:	80 91 12 07 	lds	r24, 0x0712	; 0x800712 <uxCurrentNumberOfTasks>
 dac:	81 50       	subi	r24, 0x01	; 1
					--uxTasksDeleted;
 dae:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <uxCurrentNumberOfTasks>
 db2:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <uxTasksDeleted>
 db6:	81 50       	subi	r24, 0x01	; 1
				}
				taskEXIT_CRITICAL();
 db8:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <uxTasksDeleted>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 dbc:	0f 90       	pop	r0
 dbe:	0f be       	out	0x3f, r0	; 63
		vPortFree( pxTCB );
 dc0:	f8 01       	movw	r30, r16
 dc2:	87 89       	ldd	r24, Z+23	; 0x17

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 dc4:	90 8d       	ldd	r25, Z+24	; 0x18
 dc6:	a4 d9       	rcall	.-3256   	; 0x110 <vPortFree>
 dc8:	c8 01       	movw	r24, r16
			{
				taskYIELD();
 dca:	a2 d9       	rcall	.-3260   	; 0x110 <vPortFree>
 dcc:	88 81       	ld	r24, Y
 dce:	82 30       	cpi	r24, 0x02	; 2
 dd0:	a0 f2       	brcs	.-88     	; 0xd7a <prvIdleTask+0x10>
 dd2:	64 dc       	rcall	.-1848   	; 0x69c <vPortYield>
 dd4:	d2 cf       	rjmp	.-92     	; 0xd7a <prvIdleTask+0x10>

00000dd6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 dd6:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxSchedulerSuspended>
 dda:	81 11       	cpse	r24, r1
 ddc:	13 c0       	rjmp	.+38     	; 0xe04 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 dde:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxTopReadyPriority>
 de2:	90 e0       	ldi	r25, 0x00	; 0
 de4:	fc 01       	movw	r30, r24
 de6:	ee 0f       	add	r30, r30
 de8:	ff 1f       	adc	r31, r31
 dea:	ee 0f       	add	r30, r30
 dec:	ff 1f       	adc	r31, r31
 dee:	ee 0f       	add	r30, r30
 df0:	ff 1f       	adc	r31, r31
 df2:	8e 0f       	add	r24, r30
 df4:	9f 1f       	adc	r25, r31
 df6:	fc 01       	movw	r30, r24
 df8:	e4 5c       	subi	r30, 0xC4	; 196
 dfa:	f8 4f       	sbci	r31, 0xF8	; 248
 dfc:	80 81       	ld	r24, Z
 dfe:	88 23       	and	r24, r24
 e00:	29 f0       	breq	.+10     	; 0xe0c <vTaskSwitchContext+0x36>
 e02:	1b c0       	rjmp	.+54     	; 0xe3a <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 e04:	81 e0       	ldi	r24, 0x01	; 1
 e06:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <xMissedYield>
 e0a:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 e0c:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxTopReadyPriority>
 e10:	81 50       	subi	r24, 0x01	; 1
 e12:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 e16:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxTopReadyPriority>
 e1a:	90 e0       	ldi	r25, 0x00	; 0
 e1c:	fc 01       	movw	r30, r24
 e1e:	ee 0f       	add	r30, r30
 e20:	ff 1f       	adc	r31, r31
 e22:	ee 0f       	add	r30, r30
 e24:	ff 1f       	adc	r31, r31
 e26:	ee 0f       	add	r30, r30
 e28:	ff 1f       	adc	r31, r31
 e2a:	8e 0f       	add	r24, r30
 e2c:	9f 1f       	adc	r25, r31
 e2e:	fc 01       	movw	r30, r24
 e30:	e4 5c       	subi	r30, 0xC4	; 196
 e32:	f8 4f       	sbci	r31, 0xF8	; 248
 e34:	80 81       	ld	r24, Z
 e36:	88 23       	and	r24, r24
 e38:	49 f3       	breq	.-46     	; 0xe0c <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 e3a:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxTopReadyPriority>
 e3e:	90 e0       	ldi	r25, 0x00	; 0
 e40:	9c 01       	movw	r18, r24
 e42:	22 0f       	add	r18, r18
 e44:	33 1f       	adc	r19, r19
 e46:	22 0f       	add	r18, r18
 e48:	33 1f       	adc	r19, r19
 e4a:	22 0f       	add	r18, r18
 e4c:	33 1f       	adc	r19, r19
 e4e:	28 0f       	add	r18, r24
 e50:	39 1f       	adc	r19, r25
 e52:	d9 01       	movw	r26, r18
 e54:	a4 5c       	subi	r26, 0xC4	; 196
 e56:	b8 4f       	sbci	r27, 0xF8	; 248
 e58:	11 96       	adiw	r26, 0x01	; 1
 e5a:	ed 91       	ld	r30, X+
 e5c:	fc 91       	ld	r31, X
 e5e:	12 97       	sbiw	r26, 0x02	; 2
 e60:	02 80       	ldd	r0, Z+2	; 0x02
 e62:	f3 81       	ldd	r31, Z+3	; 0x03
 e64:	e0 2d       	mov	r30, r0
 e66:	12 96       	adiw	r26, 0x02	; 2
 e68:	fc 93       	st	X, r31
 e6a:	ee 93       	st	-X, r30
 e6c:	11 97       	sbiw	r26, 0x01	; 1
 e6e:	21 5c       	subi	r18, 0xC1	; 193
 e70:	38 4f       	sbci	r19, 0xF8	; 248
 e72:	e2 17       	cp	r30, r18
 e74:	f3 07       	cpc	r31, r19
 e76:	29 f4       	brne	.+10     	; 0xe82 <vTaskSwitchContext+0xac>
 e78:	22 81       	ldd	r18, Z+2	; 0x02
 e7a:	33 81       	ldd	r19, Z+3	; 0x03
 e7c:	fd 01       	movw	r30, r26
 e7e:	32 83       	std	Z+2, r19	; 0x02
 e80:	21 83       	std	Z+1, r18	; 0x01
 e82:	fc 01       	movw	r30, r24
 e84:	ee 0f       	add	r30, r30
 e86:	ff 1f       	adc	r31, r31
 e88:	ee 0f       	add	r30, r30
 e8a:	ff 1f       	adc	r31, r31
 e8c:	ee 0f       	add	r30, r30
 e8e:	ff 1f       	adc	r31, r31
 e90:	8e 0f       	add	r24, r30
 e92:	9f 1f       	adc	r25, r31
 e94:	fc 01       	movw	r30, r24
 e96:	e4 5c       	subi	r30, 0xC4	; 196
 e98:	f8 4f       	sbci	r31, 0xF8	; 248
 e9a:	01 80       	ldd	r0, Z+1	; 0x01
 e9c:	f2 81       	ldd	r31, Z+2	; 0x02
 e9e:	e0 2d       	mov	r30, r0
 ea0:	86 81       	ldd	r24, Z+6	; 0x06
 ea2:	97 81       	ldd	r25, Z+7	; 0x07
 ea4:	90 93 61 07 	sts	0x0761, r25	; 0x800761 <pxCurrentTCB+0x1>
 ea8:	80 93 60 07 	sts	0x0760, r24	; 0x800760 <pxCurrentTCB>
 eac:	08 95       	ret

00000eae <memset>:
 eae:	dc 01       	movw	r26, r24
 eb0:	01 c0       	rjmp	.+2      	; 0xeb4 <memset+0x6>
 eb2:	6d 93       	st	X+, r22
 eb4:	41 50       	subi	r20, 0x01	; 1
 eb6:	50 40       	sbci	r21, 0x00	; 0
 eb8:	e0 f7       	brcc	.-8      	; 0xeb2 <memset+0x4>
 eba:	08 95       	ret

00000ebc <strncpy>:
 ebc:	fb 01       	movw	r30, r22
 ebe:	dc 01       	movw	r26, r24
 ec0:	41 50       	subi	r20, 0x01	; 1
 ec2:	50 40       	sbci	r21, 0x00	; 0
 ec4:	48 f0       	brcs	.+18     	; 0xed8 <strncpy+0x1c>
 ec6:	01 90       	ld	r0, Z+
 ec8:	0d 92       	st	X+, r0
 eca:	00 20       	and	r0, r0
 ecc:	c9 f7       	brne	.-14     	; 0xec0 <strncpy+0x4>
 ece:	01 c0       	rjmp	.+2      	; 0xed2 <strncpy+0x16>
 ed0:	1d 92       	st	X+, r1
 ed2:	41 50       	subi	r20, 0x01	; 1
 ed4:	50 40       	sbci	r21, 0x00	; 0
 ed6:	e0 f7       	brcc	.-8      	; 0xed0 <strncpy+0x14>
 ed8:	08 95       	ret

00000eda <_exit>:
 eda:	f8 94       	cli

00000edc <__stop_program>:
 edc:	ff cf       	rjmp	.-2      	; 0xedc <__stop_program>
